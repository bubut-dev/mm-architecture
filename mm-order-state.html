<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MM Order State Management</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: #fff;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 26px;
            color: #00d9ff;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 40px;
            color: #888;
            font-size: 14px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 18px;
            color: #00d9ff;
            margin-bottom: 20px;
            padding-left: 15px;
            border-left: 3px solid #00d9ff;
        }
        
        /* Problem illustration */
        .problem-box {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .problem-title {
            color: #ff6b6b;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        /* Timeline */
        .timeline {
            position: relative;
            padding: 20px 0;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255,255,255,0.1);
        }
        .timeline-event {
            position: relative;
            padding-left: 50px;
            margin-bottom: 20px;
        }
        .timeline-event::before {
            content: '';
            position: absolute;
            left: 14px;
            top: 5px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00d9ff;
        }
        .timeline-event.problem::before { background: #ff6b6b; }
        .timeline-event.solution::before { background: #4ecdc4; }
        .event-time {
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }
        .event-content {
            font-size: 13px;
        }
        .event-note {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }
        
        /* State diagram */
        .state-diagram {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .state-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .state-box {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            min-width: 150px;
        }
        .state-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
        }
        .state-value {
            font-weight: 600;
            font-size: 16px;
        }
        .state-box.confirmed { border-left: 3px solid #4ecdc4; }
        .state-box.confirmed .state-value { color: #4ecdc4; }
        .state-box.pending { border-left: 3px solid #ffeaa7; }
        .state-box.pending .state-value { color: #ffeaa7; }
        .state-box.effective { border-left: 3px solid #00d9ff; }
        .state-box.effective .state-value { color: #00d9ff; }
        .state-box.limit { border-left: 3px solid #ff6b6b; }
        .state-box.limit .state-value { color: #ff6b6b; }
        
        .operator {
            font-size: 20px;
            color: #666;
        }
        
        /* Code block */
        .code-block {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .code-comment { color: #666; }
        .code-keyword { color: #ff6b6b; }
        .code-string { color: #4ecdc4; }
        .code-var { color: #ffeaa7; }
        
        /* Solution options */
        .solutions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .solution-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        .solution-card:hover {
            background: rgba(255,255,255,0.08);
        }
        .solution-card.recommended {
            border-color: rgba(78, 205, 196, 0.5);
            background: rgba(78, 205, 196, 0.05);
        }
        .solution-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .badge {
            font-size: 9px;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }
        .solution-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.5;
        }
        .pros-cons {
            font-size: 11px;
        }
        .pros-cons li {
            margin: 4px 0;
            padding-left: 18px;
            position: relative;
        }
        .pros-cons li.pro::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #4ecdc4;
        }
        .pros-cons li.con::before {
            content: "‚úó";
            position: absolute;
            left: 0;
            color: #ff6b6b;
        }
        
        /* Flow diagram */
        .flow-diagram {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .flow-title {
            font-size: 14px;
            color: #ffeaa7;
            margin-bottom: 15px;
            text-align: center;
        }
        .flow-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .flow-step {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 11px;
            text-align: center;
        }
        .flow-step.redis { border-left: 3px solid #ff6b6b; }
        .flow-step.engine { border-left: 3px solid #ffeaa7; }
        .flow-step.decision { border-left: 3px solid #4ecdc4; }
        .flow-arrow { color: #444; }
        
        /* Multi-instance diagram */
        .multi-instance {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .instance {
            background: rgba(255,255,255,0.05);
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .instance-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #ffeaa7;
        }
        .instance-pairs {
            font-size: 11px;
            color: #aaa;
        }
        
        /* Insight box */
        .insight {
            background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(162,155,254,0.1));
            border: 1px solid rgba(0,217,255,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        .insight-title {
            color: #00d9ff;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .insight-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.6;
        }
        
        @media (max-width: 768px) {
            .multi-instance {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>üîÑ Order State: Pending vs Confirmed</h1>
    <p class="subtitle">How to avoid over-buying while waiting for order confirmation</p>
    
    <div class="container">
        <!-- Problem Section -->
        <div class="section">
            <div class="section-title">‚ùå The Problem: Race Condition</div>
            
            <div class="problem-box">
                <div class="problem-title">Without pending state tracking:</div>
                <div class="timeline">
                    <div class="timeline-event">
                        <div class="event-time">T+0ms</div>
                        <div class="event-content">Price event ‚Üí Strategy says BUY 10 ETH</div>
                    </div>
                    <div class="timeline-event">
                        <div class="event-time">T+5ms</div>
                        <div class="event-content">Order sent to exchange (waiting for confirmation...)</div>
                    </div>
                    <div class="timeline-event problem">
                        <div class="event-time">T+50ms</div>
                        <div class="event-content">Another price event ‚Üí Strategy checks inventory</div>
                        <div class="event-note">‚ö†Ô∏è Confirmed inventory still = 0 (order not confirmed yet)</div>
                    </div>
                    <div class="timeline-event problem">
                        <div class="event-time">T+55ms</div>
                        <div class="event-content">Strategy says BUY 10 ETH again!</div>
                        <div class="event-note">üí• Double buy! We now have 20 ETH exposure instead of 10</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Solution: Effective Position -->
        <div class="section">
            <div class="section-title">‚úÖ Solution: Track Effective Position</div>
            
            <p style="margin-bottom: 20px; color: #aaa; font-size: 14px;">
                Maintain two states: <strong>confirmed</strong> (from fills) + <strong>pending</strong> (orders in-flight)
            </p>
            
            <div class="state-diagram">
                <div class="state-row">
                    <div class="state-box confirmed">
                        <div class="state-label">Confirmed Position</div>
                        <div class="state-value">0 ETH</div>
                    </div>
                    <span class="operator">+</span>
                    <div class="state-box pending">
                        <div class="state-label">Pending Buy Orders</div>
                        <div class="state-value">10 ETH</div>
                    </div>
                    <span class="operator">-</span>
                    <div class="state-box pending">
                        <div class="state-label">Pending Sell Orders</div>
                        <div class="state-value">0 ETH</div>
                    </div>
                    <span class="operator">=</span>
                    <div class="state-box effective">
                        <div class="state-label">Effective Position</div>
                        <div class="state-value">10 ETH</div>
                    </div>
                </div>
                
                <div class="state-row">
                    <div class="state-box limit">
                        <div class="state-label">Max Position Limit</div>
                        <div class="state-value">10 ETH</div>
                    </div>
                    <span class="operator" style="font-size: 14px;">‚Üí</span>
                    <div class="state-box decision">
                        <div class="state-label">Decision</div>
                        <div class="state-value">‚ùå Can't Buy More</div>
                    </div>
                </div>
            </div>
            
            <div class="code-block">
<span class="code-comment">// State structure</span>
<span class="code-keyword">struct</span> <span class="code-var">TradingState</span> {
    confirmed_inventory: f64,      <span class="code-comment">// From exchange fills</span>
    pending_buy_orders: HashMap&lt;OrderId, f64&gt;,
    pending_sell_orders: HashMap&lt;OrderId, f64&gt;,
}

<span class="code-keyword">fn</span> <span class="code-var">effective_position</span>(&self) -> f64 {
    self.confirmed_inventory
        + self.pending_buy_orders.values().sum()
        - self.pending_sell_orders.values().sum()
}

<span class="code-keyword">fn</span> <span class="code-var">can_buy</span>(&self, amount: f64, max_position: f64) -> bool {
    self.effective_position() + amount <= max_position
}

<span class="code-comment">// When order sent</span>
<span class="code-keyword">fn</span> <span class="code-var">on_order_sent</span>(&mut self, order_id: OrderId, side: Side, qty: f64) {
    <span class="code-keyword">match</span> side {
        Side::Buy => self.pending_buy_orders.insert(order_id, qty),
        Side::Sell => self.pending_sell_orders.insert(order_id, qty),
    }
}

<span class="code-comment">// When order confirmed/filled</span>
<span class="code-keyword">fn</span> <span class="code-var">on_fill</span>(&mut self, order_id: OrderId, side: Side, qty: f64) {
    <span class="code-keyword">match</span> side {
        Side::Buy => {
            self.pending_buy_orders.remove(&order_id);
            self.confirmed_inventory += qty;
        }
        Side::Sell => {
            self.pending_sell_orders.remove(&order_id);
            self.confirmed_inventory -= qty;
        }
    }
}

<span class="code-comment">// When order rejected/expired</span>
<span class="code-keyword">fn</span> <span class="code-var">on_order_cancelled</span>(&mut self, order_id: OrderId, side: Side) {
    <span class="code-keyword">match</span> side {
        Side::Buy => self.pending_buy_orders.remove(&order_id),
        Side::Sell => self.pending_sell_orders.remove(&order_id),
    }
}
            </div>
            
            <div class="flow-diagram">
                <div class="flow-title">üìç Correct Flow with Pending State</div>
                <div class="flow-row">
                    <div class="flow-step engine">Price event</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step decision">Check effective_position</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step decision">10 ETH < 10 limit?</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step engine">No room ‚Üí SKIP</div>
                </div>
            </div>
        </div>
        
        <!-- Multi-Instance Problem -->
        <div class="section">
            <div class="section-title">üîÄ Problem 2: Multiple Instances</div>
            
            <p style="margin-bottom: 20px; color: #aaa; font-size: 14px;">
                If you have 5 instances per exchange, how do they coordinate pending state?
            </p>
            
            <div class="solutions-grid">
                <div class="solution-card recommended">
                    <div class="solution-title">
                        Option A: Partition by Pair
                        <span class="badge">RECOMMENDED</span>
                    </div>
                    <div class="solution-desc">
                        Each instance owns specific trading pairs. No overlap = no coordination needed.
                    </div>
                    <ul class="pros-cons">
                        <li class="pro">No race conditions</li>
                        <li class="pro">Local state is sufficient</li>
                        <li class="pro">Simple, fast</li>
                        <li class="con">Uneven load if some pairs are hot</li>
                    </ul>
                </div>
                
                <div class="solution-card">
                    <div class="solution-title">Option B: Redis Coordination</div>
                    <div class="solution-desc">
                        Share pending orders in Redis. Use atomic operations before sending orders.
                    </div>
                    <ul class="pros-cons">
                        <li class="pro">Any instance can trade any pair</li>
                        <li class="pro">Flexible scaling</li>
                        <li class="con">Redis in critical path (latency)</li>
                        <li class="con">More complex</li>
                    </ul>
                </div>
                
                <div class="solution-card">
                    <div class="solution-title">Option C: Central Order Manager</div>
                    <div class="solution-desc">
                        All order requests go through a single Order Manager service that tracks all pending state.
                    </div>
                    <ul class="pros-cons">
                        <li class="pro">Single source of truth</li>
                        <li class="pro">Easy to audit</li>
                        <li class="con">Single point of failure</li>
                        <li class="con">Added latency</li>
                    </ul>
                </div>
            </div>
            
            <div class="flow-diagram" style="margin-top: 30px;">
                <div class="flow-title">üéØ Recommended: Partition by Trading Pair</div>
                <div class="multi-instance">
                    <div class="instance">
                        <div class="instance-title">Instance 1</div>
                        <div class="instance-pairs">
                            ETH/USDT<br>
                            ETH/USDC
                        </div>
                    </div>
                    <div class="instance">
                        <div class="instance-title">Instance 2</div>
                        <div class="instance-pairs">
                            BTC/USDT<br>
                            BTC/USDC
                        </div>
                    </div>
                    <div class="instance">
                        <div class="instance-title">Instance 3</div>
                        <div class="instance-pairs">
                            SOL/USDT<br>
                            AVAX/USDT
                        </div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 12px; color: #888; margin-top: 15px;">
                    Each instance manages its own pairs ‚Üí local pending state is sufficient<br>
                    Cross-pair risk limits still shared via Redis (but not pending orders)
                </p>
            </div>
        </div>
        
        <!-- Redis Coordination Detail -->
        <div class="section">
            <div class="section-title">üîß Option B Detail: Redis Atomic Reservation</div>
            
            <p style="margin-bottom: 15px; color: #aaa; font-size: 14px;">
                If you need multiple instances trading the same pair, use Redis for atomic "reserve capacity" checks:
            </p>
            
            <div class="code-block">
<span class="code-comment">-- Lua script for atomic check-and-reserve</span>
<span class="code-keyword">local</span> current = tonumber(redis.call(<span class="code-string">'GET'</span>, KEYS[1])) or 0
<span class="code-keyword">local</span> pending = tonumber(redis.call(<span class="code-string">'GET'</span>, KEYS[2])) or 0
<span class="code-keyword">local</span> max_position = tonumber(ARGV[1])
<span class="code-keyword">local</span> order_qty = tonumber(ARGV[2])
<span class="code-keyword">local</span> order_id = ARGV[3]

<span class="code-keyword">local</span> effective = current + pending

<span class="code-keyword">if</span> effective + order_qty <= max_position <span class="code-keyword">then</span>
    <span class="code-comment">-- Reserve capacity</span>
    redis.call(<span class="code-string">'INCRBYFLOAT'</span>, KEYS[2], order_qty)
    redis.call(<span class="code-string">'HSET'</span>, KEYS[3], order_id, order_qty)
    <span class="code-keyword">return</span> 1  <span class="code-comment">-- Approved</span>
<span class="code-keyword">else</span>
    <span class="code-keyword">return</span> 0  <span class="code-comment">-- Rejected: would exceed limit</span>
<span class="code-keyword">end</span>
            </div>
            
            <div class="flow-diagram">
                <div class="flow-title">Flow with Redis Coordination</div>
                <div class="flow-row">
                    <div class="flow-step engine">Strategy: BUY 10</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step redis">Redis: EVAL reserve_script</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step decision">Approved?</div>
                </div>
                <div class="flow-row">
                    <span style="color: #4ecdc4; font-size: 12px;">Yes ‚Üí</span>
                    <div class="flow-step engine">Send order to exchange</div>
                    <span class="flow-arrow">‚Üí</span>
                    <div class="flow-step engine">On fill: move pending ‚Üí confirmed</div>
                </div>
                <div class="flow-row">
                    <span style="color: #ff6b6b; font-size: 12px;">No ‚Üí</span>
                    <div class="flow-step engine">Skip order (at capacity)</div>
                </div>
            </div>
        </div>
        
        <!-- Your specific question -->
        <div class="section">
            <div class="section-title">üí° Your Question: Price Dropped, Should We Buy More?</div>
            
            <p style="margin-bottom: 15px; color: #aaa; font-size: 14px;">
                "Maybe we need to buy more because the price dropped even if the other order is still not confirmed"
            </p>
            
            <div class="insight">
                <div class="insight-title">This is a strategy decision, not an architecture problem</div>
                <div class="insight-text">
                    The architecture gives you the <strong>effective position</strong>. Your strategy decides what to do with it:<br><br>
                    
                    <strong>Conservative strategy:</strong><br>
                    "I have 10 ETH pending. Max is 10. I can't buy more until confirmed."<br><br>
                    
                    <strong>Aggressive strategy:</strong><br>
                    "Price dropped 5%. Even with 10 ETH pending, I want to increase my limit temporarily to 15 ETH for this opportunity."<br><br>
                    
                    <strong>The architecture supports both:</strong><br>
                    <code>can_buy(qty, dynamic_limit)</code> ‚Äî the limit can be adjusted by the strategy based on market conditions.<br><br>
                    
                    But you always know your <strong>true exposure</strong> (effective position). The decision to exceed normal limits is explicit, not accidental.
                </div>
            </div>
        </div>
        
        <!-- Summary -->
        <div class="section">
            <div class="section-title">üìã Summary</div>
            
            <div class="solutions-grid">
                <div class="solution-card" style="border-left: 3px solid #4ecdc4;">
                    <div class="solution-title">Track Pending State</div>
                    <div class="solution-desc">
                        <code>effective = confirmed + pending_buys - pending_sells</code><br><br>
                        Use effective position for all decisions.
                    </div>
                </div>
                
                <div class="solution-card" style="border-left: 3px solid #ffeaa7;">
                    <div class="solution-title">Partition by Pair</div>
                    <div class="solution-desc">
                        Each instance owns specific pairs.<br><br>
                        Local state is sufficient. No Redis coordination for pending.
                    </div>
                </div>
                
                <div class="solution-card" style="border-left: 3px solid #ff6b6b;">
                    <div class="solution-title">Handle Edge Cases</div>
                    <div class="solution-desc">
                        ‚Ä¢ Order rejected ‚Üí remove from pending<br>
                        ‚Ä¢ Order expired ‚Üí remove from pending<br>
                        ‚Ä¢ Partial fill ‚Üí update pending qty
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
