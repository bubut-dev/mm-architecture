<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MM High Availability & Coordination</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: #fff;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 26px;
            color: #00d9ff;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 40px;
            color: #888;
            font-size: 14px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 18px;
            color: #00d9ff;
            margin-bottom: 20px;
            padding-left: 15px;
            border-left: 3px solid #00d9ff;
        }
        
        /* Problem box */
        .problem-box {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .problem-title {
            color: #ff6b6b;
            font-weight: 600;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        /* Diagram boxes */
        .diagram {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }
        .diagram-title {
            text-align: center;
            font-size: 14px;
            color: #ffeaa7;
            margin-bottom: 20px;
        }
        
        /* Instance boxes */
        .instances-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .instance-box {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
            min-width: 150px;
        }
        .instance-box.active {
            border-color: rgba(78, 205, 196, 0.5);
            background: rgba(78, 205, 196, 0.1);
        }
        .instance-box.passive {
            border-color: rgba(255, 255, 255, 0.2);
            opacity: 0.6;
        }
        .instance-box.problem {
            border-color: rgba(255, 107, 107, 0.5);
            background: rgba(255, 107, 107, 0.1);
        }
        .instance-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        .instance-name {
            font-weight: 600;
            font-size: 14px;
        }
        .instance-status {
            font-size: 11px;
            margin-top: 8px;
            padding: 3px 10px;
            border-radius: 10px;
            display: inline-block;
        }
        .instance-status.trading {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }
        .instance-status.standby {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        .instance-status.danger {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }
        
        /* Flow arrows */
        .arrow-down {
            text-align: center;
            color: #444;
            padding: 10px 0;
            font-size: 20px;
        }
        .arrow-label {
            font-size: 11px;
            color: #888;
            background: rgba(0,0,0,0.3);
            padding: 4px 12px;
            border-radius: 10px;
            display: inline-block;
        }
        
        /* Central components */
        .central-box {
            background: rgba(255,255,255,0.05);
            border: 2px solid;
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
            margin: 0 auto;
            max-width: 300px;
        }
        .central-box.redis {
            border-color: rgba(255, 107, 107, 0.5);
        }
        .central-box.gateway {
            border-color: rgba(162, 155, 254, 0.5);
        }
        .central-box .box-title {
            font-weight: 600;
            margin-bottom: 8px;
        }
        .central-box.redis .box-title { color: #ff6b6b; }
        .central-box.gateway .box-title { color: #a29bfe; }
        .central-box .box-desc {
            font-size: 11px;
            color: #aaa;
        }
        
        /* Solution cards */
        .solutions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        .solution-card {
            background: rgba(255,255,255,0.03);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid transparent;
        }
        .solution-card.recommended {
            border-color: rgba(78, 205, 196, 0.4);
            background: rgba(78, 205, 196, 0.03);
        }
        .solution-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .solution-title {
            font-weight: 600;
            font-size: 16px;
        }
        .badge {
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }
        .solution-desc {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        /* Pros/cons */
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            font-size: 12px;
        }
        .pros h4, .cons h4 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .pros h4 { color: #4ecdc4; }
        .cons h4 { color: #ff6b6b; }
        .pros li, .cons li {
            margin: 5px 0;
            padding-left: 15px;
            position: relative;
            color: #aaa;
        }
        .pros li::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #4ecdc4;
        }
        .cons li::before {
            content: "‚úó";
            position: absolute;
            left: 0;
            color: #ff6b6b;
        }
        
        /* Code block */
        .code-block {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .code-comment { color: #666; }
        .code-keyword { color: #ff6b6b; }
        .code-string { color: #4ecdc4; }
        
        /* Comparison table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 20px;
        }
        .comparison-table th, .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .comparison-table th {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
        }
        .comparison-table td:first-child {
            color: #00d9ff;
        }
        .comparison-table .good { color: #4ecdc4; }
        .comparison-table .bad { color: #ff6b6b; }
        .comparison-table .neutral { color: #ffeaa7; }
        
        /* Insight */
        .insight {
            background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(162,155,254,0.1));
            border: 1px solid rgba(0,217,255,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
        }
        .insight-title {
            color: #00d9ff;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .insight-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.6;
        }
        
        @media (max-width: 768px) {
            .solutions-grid {
                grid-template-columns: 1fr;
            }
            .pros-cons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>üîÑ HA Coordination: 2 Instances Per Pair</h1>
    <p class="subtitle">How to avoid double-spend with redundant instances</p>
    
    <div class="container">
        <!-- Problem Statement -->
        <div class="section">
            <div class="section-title">‚ùå The Problem: Redundancy Creates Coordination Need</div>
            
            <div class="problem-box">
                <div class="problem-title">You're right ‚Äî partition by pair alone doesn't work with redundancy:</div>
                
                <div class="diagram">
                    <div class="diagram-title">ETH/USDT Pair ‚Äî Two Instances for HA</div>
                    
                    <div class="instances-row">
                        <div class="instance-box problem">
                            <div class="instance-label">Instance 1</div>
                            <div class="instance-name">ETH/USDT</div>
                            <div class="instance-status danger">Sees price ‚Üí BUY 10</div>
                        </div>
                        <div class="instance-box problem">
                            <div class="instance-label">Instance 2</div>
                            <div class="instance-name">ETH/USDT</div>
                            <div class="instance-status danger">Sees price ‚Üí BUY 10</div>
                        </div>
                    </div>
                    
                    <div class="arrow-down">
                        <span class="arrow-label">üí• Both send orders ‚Üí Double spend!</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Solutions -->
        <div class="section">
            <div class="section-title">‚úÖ Real Solutions for HA + Coordination</div>
            
            <div class="solutions-grid">
                <!-- Option 1: Active-Passive -->
                <div class="solution-card">
                    <div class="solution-header">
                        <div class="solution-title">Option 1: Active-Passive (Leader Election)</div>
                    </div>
                    <div class="solution-desc">
                        Only ONE instance is active at a time. The other is hot standby. Use Redis/etcd for leader election.
                    </div>
                    
                    <div class="diagram" style="padding: 15px;">
                        <div class="instances-row" style="margin: 10px 0;">
                            <div class="instance-box active" style="padding: 10px 20px;">
                                <div class="instance-name">Instance 1</div>
                                <div class="instance-status trading">LEADER ‚Äî Trading</div>
                            </div>
                            <div class="instance-box passive" style="padding: 10px 20px;">
                                <div class="instance-name">Instance 2</div>
                                <div class="instance-status standby">FOLLOWER ‚Äî Standby</div>
                            </div>
                        </div>
                        <div class="central-box redis" style="padding: 10px; max-width: 200px;">
                            <div class="box-title" style="font-size: 12px;">Redis Lock</div>
                            <div class="box-desc">Leader heartbeat</div>
                        </div>
                    </div>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>Pros</h4>
                            <ul>
                                <li>Simple ‚Äî no coordination during trading</li>
                                <li>Local pending state is sufficient</li>
                                <li>No Redis in hot path</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>Cons</h4>
                            <ul>
                                <li>Failover delay (1-5 seconds)</li>
                                <li>Standby is idle (wasted resource)</li>
                                <li>Brief gap during leader election</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- Option 2: Active-Active with Redis -->
                <div class="solution-card recommended">
                    <div class="solution-header">
                        <div class="solution-title">Option 2: Active-Active with Redis Lock</div>
                        <span class="badge">RECOMMENDED</span>
                    </div>
                    <div class="solution-desc">
                        Both instances are active. Before any order, atomically reserve capacity in Redis. First one wins.
                    </div>
                    
                    <div class="diagram" style="padding: 15px;">
                        <div class="instances-row" style="margin: 10px 0;">
                            <div class="instance-box active" style="padding: 10px 20px;">
                                <div class="instance-name">Instance 1</div>
                                <div class="instance-status trading">Active</div>
                            </div>
                            <div class="instance-box active" style="padding: 10px 20px;">
                                <div class="instance-name">Instance 2</div>
                                <div class="instance-status trading">Active</div>
                            </div>
                        </div>
                        <div class="arrow-down">‚Üì Both check Redis before order</div>
                        <div class="central-box redis" style="padding: 10px; max-width: 250px;">
                            <div class="box-title" style="font-size: 12px;">Redis (Atomic Lock)</div>
                            <div class="box-desc">pending_orders + capacity check</div>
                        </div>
                    </div>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>Pros</h4>
                            <ul>
                                <li>Both instances utilized</li>
                                <li>Instant failover (no election)</li>
                                <li>Load balancing possible</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>Cons</h4>
                            <ul>
                                <li>Redis in critical path (~1ms)</li>
                                <li>Redis becomes SPOF</li>
                                <li>More complex logic</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- Option 3: Central Order Gateway -->
                <div class="solution-card">
                    <div class="solution-header">
                        <div class="solution-title">Option 3: Central Order Gateway</div>
                    </div>
                    <div class="solution-desc">
                        Instances are "strategy engines" only. All order requests go to a single Order Gateway that tracks state and sends to exchange.
                    </div>
                    
                    <div class="diagram" style="padding: 15px;">
                        <div class="instances-row" style="margin: 10px 0;">
                            <div class="instance-box" style="padding: 10px 20px;">
                                <div class="instance-name">Strategy 1</div>
                                <div class="instance-status">Decision only</div>
                            </div>
                            <div class="instance-box" style="padding: 10px 20px;">
                                <div class="instance-name">Strategy 2</div>
                                <div class="instance-status">Decision only</div>
                            </div>
                        </div>
                        <div class="arrow-down">‚Üì Order requests</div>
                        <div class="central-box gateway" style="padding: 10px; max-width: 250px;">
                            <div class="box-title" style="font-size: 12px;">Order Gateway</div>
                            <div class="box-desc">Tracks all pending, sends to exchange</div>
                        </div>
                    </div>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>Pros</h4>
                            <ul>
                                <li>Single source of truth</li>
                                <li>Clean separation</li>
                                <li>Easy to audit all orders</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>Cons</h4>
                            <ul>
                                <li>Gateway is SPOF (needs own HA)</li>
                                <li>Added latency (2 hops)</li>
                                <li>More infrastructure</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Option 2 Detail -->
        <div class="section">
            <div class="section-title">üîß Option 2 Detail: Active-Active with Redis</div>
            
            <p style="margin-bottom: 15px; color: #aaa; font-size: 14px;">
                This is what most serious trading firms use. The key is making the capacity check <strong>atomic</strong>.
            </p>
            
            <div class="code-block">
<span class="code-comment">-- Lua script: atomic check-and-reserve (runs in Redis)</span>
<span class="code-keyword">local</span> key_confirmed = KEYS[1]     <span class="code-comment">-- "eth:confirmed"</span>
<span class="code-keyword">local</span> key_pending = KEYS[2]       <span class="code-comment">-- "eth:pending"</span>
<span class="code-keyword">local</span> key_orders = KEYS[3]        <span class="code-comment">-- "eth:pending_orders" (hash)</span>

<span class="code-keyword">local</span> max_position = tonumber(ARGV[1])
<span class="code-keyword">local</span> order_qty = tonumber(ARGV[2])
<span class="code-keyword">local</span> order_id = ARGV[3]
<span class="code-keyword">local</span> instance_id = ARGV[4]

<span class="code-comment">-- Calculate effective position</span>
<span class="code-keyword">local</span> confirmed = tonumber(redis.call(<span class="code-string">'GET'</span>, key_confirmed)) or 0
<span class="code-keyword">local</span> pending = tonumber(redis.call(<span class="code-string">'GET'</span>, key_pending)) or 0
<span class="code-keyword">local</span> effective = confirmed + pending

<span class="code-comment">-- Check if we have room</span>
<span class="code-keyword">if</span> effective + order_qty <= max_position <span class="code-keyword">then</span>
    <span class="code-comment">-- Reserve the capacity atomically</span>
    redis.call(<span class="code-string">'INCRBYFLOAT'</span>, key_pending, order_qty)
    redis.call(<span class="code-string">'HSET'</span>, key_orders, order_id, 
               cjson.encode({qty=order_qty, instance=instance_id, ts=redis.call(<span class="code-string">'TIME'</span>)[1]}))
    <span class="code-keyword">return</span> {1, effective + order_qty}  <span class="code-comment">-- Approved, new effective</span>
<span class="code-keyword">else</span>
    <span class="code-keyword">return</span> {0, effective}  <span class="code-comment">-- Rejected, current effective</span>
<span class="code-keyword">end</span>
            </div>
            
            <div class="code-block">
<span class="code-comment">// Trading engine (Rust/Go)</span>
<span class="code-keyword">fn</span> try_place_order(side: Side, qty: f64) -> Result&lt;Order&gt; {
    <span class="code-keyword">let</span> order_id = generate_order_id();
    
    <span class="code-comment">// Atomic check-and-reserve in Redis</span>
    <span class="code-keyword">let</span> (approved, effective) = redis.eval(
        RESERVE_SCRIPT,
        keys: [<span class="code-string">"eth:confirmed"</span>, <span class="code-string">"eth:pending"</span>, <span class="code-string">"eth:pending_orders"</span>],
        args: [max_position, qty, order_id, instance_id]
    )?;
    
    <span class="code-keyword">if</span> !approved {
        <span class="code-keyword">return</span> Err(<span class="code-string">"At capacity"</span>);
    }
    
    <span class="code-comment">// Capacity reserved ‚Äî now safe to send order</span>
    <span class="code-keyword">match</span> exchange.send_order(order_id, side, qty) {
        Ok(order) => Ok(order),
        Err(e) => {
            <span class="code-comment">// Order failed ‚Äî release the reservation</span>
            redis.eval(RELEASE_SCRIPT, [order_id, qty]);
            Err(e)
        }
    }
}
            </div>
            
            <div class="diagram">
                <div class="diagram-title">Flow: Two Instances, Same Price Event</div>
                <table class="comparison-table">
                    <tr>
                        <th>Time</th>
                        <th>Instance 1</th>
                        <th>Instance 2</th>
                        <th>Redis State</th>
                    </tr>
                    <tr>
                        <td>T+0</td>
                        <td>Receives price event</td>
                        <td>Receives price event</td>
                        <td>pending=0, confirmed=0</td>
                    </tr>
                    <tr>
                        <td>T+1ms</td>
                        <td>Decides BUY 10</td>
                        <td>Decides BUY 10</td>
                        <td>‚Äî</td>
                    </tr>
                    <tr>
                        <td>T+2ms</td>
                        <td class="good">EVAL reserve ‚Üí ‚úì Approved</td>
                        <td>(waiting for Redis)</td>
                        <td>pending=10</td>
                    </tr>
                    <tr>
                        <td>T+3ms</td>
                        <td>Sends order to exchange</td>
                        <td class="bad">EVAL reserve ‚Üí ‚úó Rejected (at limit)</td>
                        <td>pending=10</td>
                    </tr>
                    <tr>
                        <td>T+50ms</td>
                        <td>Fill confirmed</td>
                        <td>‚Äî</td>
                        <td>pending=0, confirmed=10</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <!-- Comparison Table -->
        <div class="section">
            <div class="section-title">üìä Comparison: Which to Choose?</div>
            
            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Active-Passive</th>
                    <th>Active-Active + Redis</th>
                    <th>Central Gateway</th>
                </tr>
                <tr>
                    <td>Latency overhead</td>
                    <td class="good">None (local state)</td>
                    <td class="neutral">~1ms (Redis call)</td>
                    <td class="bad">~2-5ms (extra hop)</td>
                </tr>
                <tr>
                    <td>Failover time</td>
                    <td class="bad">1-5 seconds</td>
                    <td class="good">Instant</td>
                    <td class="neutral">Depends on gateway HA</td>
                </tr>
                <tr>
                    <td>Resource utilization</td>
                    <td class="bad">50% (standby idle)</td>
                    <td class="good">100%</td>
                    <td class="good">100%</td>
                </tr>
                <tr>
                    <td>Complexity</td>
                    <td class="good">Simple</td>
                    <td class="neutral">Medium</td>
                    <td class="bad">High</td>
                </tr>
                <tr>
                    <td>Redis dependency</td>
                    <td class="good">Leader election only</td>
                    <td class="bad">Every order</td>
                    <td class="good">None (gateway has state)</td>
                </tr>
                <tr>
                    <td>Best for</td>
                    <td>Lower frequency MM</td>
                    <td><strong>High frequency MM</strong></td>
                    <td>Multi-strategy firms</td>
                </tr>
            </table>
            
            <div class="insight">
                <div class="insight-title">üí° Key Insight</div>
                <div class="insight-text">
                    "For high-availability with 2+ instances per trading pair, I'd use <strong>Active-Active with Redis coordination</strong>. 
                    Each instance runs the same strategy, but before sending any order, it atomically reserves capacity in Redis using a Lua script. 
                    First instance to reserve wins; others see 'at capacity' and skip.<br><br>
                    
                    This gives us:<br>
                    ‚Ä¢ <strong>Instant failover</strong> ‚Äî if one instance dies, the other keeps trading<br>
                    ‚Ä¢ <strong>No double-spend</strong> ‚Äî Redis is single source of truth for pending state<br>
                    ‚Ä¢ <strong>~1ms overhead</strong> ‚Äî acceptable for most MM strategies<br><br>
                    
                    For ultra-low-latency (HFT), I'd consider Active-Passive with fast leader election instead, accepting the brief failover gap."
                </div>
            </div>
        </div>
    </div>
</body>
</html>
